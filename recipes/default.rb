# frozen_string_literal: true

#
# Cookbook:: letsencryptaws
# Recipe:: default
#
# Copyright:: 2020, Matt Kulka
#

group node['letsencryptaws']['ssl_group'] do
  append true
  action :create
end

directory node['letsencryptaws']['ssl_cert_dir'] do
  recursive true
  owner node['letsencryptaws']['ssl_owner']
  group node['letsencryptaws']['ssl_group']
  mode '755'
end

directory node['letsencryptaws']['ssl_key_dir'] do
  recursive true
  owner node['letsencryptaws']['ssl_owner']
  group node['letsencryptaws']['ssl_group']
  mode '750'
end

# Default keys
remote_file_s3 ::File.join(node['letsencryptaws']['ssl_cert_dir'], 'default.crt') do
  remote_path "/#{node['letsencryptaws']['sync_path']}/default-ssl/default.crt"
  bucket node['letsencryptaws']['sync_bucket']
  aws_access_key_id (lazy { node['aws_access_key_id'] || aws_creds('aws_access_key_id') })
  aws_secret_access_key (lazy { node['aws_secret_access_key'] || aws_creds('aws_secret_access_key') })
  aws_session_token (lazy { node['aws_session_token'] || aws_creds('aws_session_token') })
  owner node['letsencryptaws']['ssl_owner']
  group node['letsencryptaws']['ssl_group']
  mode '644'
  sensitive true
end

remote_file_s3 ::File.join(node['letsencryptaws']['ssl_cert_dir'], 'default.ca') do
  remote_path "/#{node['letsencryptaws']['sync_path']}/default-ssl/ca.crt"
  bucket node['letsencryptaws']['sync_bucket']
  aws_access_key_id (lazy { node['aws_access_key_id'] || aws_creds('aws_access_key_id') })
  aws_secret_access_key (lazy { node['aws_secret_access_key'] || aws_creds('aws_secret_access_key') })
  aws_session_token (lazy { node['aws_session_token'] || aws_creds('aws_session_token') })
  owner node['letsencryptaws']['ssl_owner']
  group node['letsencryptaws']['ssl_group']
  mode '644'
  sensitive true
end

remote_file_s3 ::File.join(node['letsencryptaws']['ssl_key_dir'], 'default.key') do
  remote_path "/#{node['letsencryptaws']['sync_path']}/default-ssl/default.key"
  bucket node['letsencryptaws']['sync_bucket']
  aws_access_key_id (lazy { node['aws_access_key_id'] || aws_creds('aws_access_key_id') })
  aws_secret_access_key (lazy { node['aws_secret_access_key'] || aws_creds('aws_secret_access_key') })
  aws_session_token (lazy { node['aws_session_token'] || aws_creds('aws_session_token') })
  owner node['letsencryptaws']['ssl_owner']
  group node['letsencryptaws']['ssl_group']
  mode '640'
  sensitive true
end

# Fake Let's Encrypt root CA for staging/test certificates
execute 'update-ca-certificates' do
  action :nothing
end

remote_file '/usr/local/share/ca-certificates/fakeroot.crt' do
  source 'https://letsencrypt.org/certs/fakelerootx1.pem'
  owner 'root'
  group 'root'
  mode '644'
  only_if { node['letsencryptaws']['test_certs'] }
  notifies :run, 'execute[update-ca-certificates]', :immediately
end

# Keys generated by certbot
node['letsencryptaws']['certs'].each_pair do |domain, _sans|
  domain = domain.sub('*', 'star')

  # Real certbot-generated certificates
  remote_file_s3 ::File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.crt") do
    remote_path "/#{node['letsencryptaws']['sync_path']}/#{domain}/cert.pem"
    bucket node['letsencryptaws']['sync_bucket']
    aws_access_key_id (lazy { node['aws_access_key_id'] || aws_creds('aws_access_key_id') })
    aws_secret_access_key (lazy { node['aws_secret_access_key'] || aws_creds('aws_secret_access_key') })
    aws_session_token (lazy { node['aws_session_token'] || aws_creds('aws_session_token') })
    owner node['letsencryptaws']['ssl_owner']
    group node['letsencryptaws']['ssl_group']
    mode '644'
    retries 0
    ignore_failure true
    sensitive true
  end

  remote_file_s3 ::File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.ca") do
    remote_path "/#{node['letsencryptaws']['sync_path']}/#{domain}/chain.pem"
    bucket node['letsencryptaws']['sync_bucket']
    aws_access_key_id (lazy { node['aws_access_key_id'] || aws_creds('aws_access_key_id') })
    aws_secret_access_key (lazy { node['aws_secret_access_key'] || aws_creds('aws_secret_access_key') })
    aws_session_token (lazy { node['aws_session_token'] || aws_creds('aws_session_token') })
    owner node['letsencryptaws']['ssl_owner']
    group node['letsencryptaws']['ssl_group']
    mode '644'
    retries 0
    ignore_failure true
    sensitive true
  end

  remote_file_s3 ::File.join(node['letsencryptaws']['ssl_key_dir'], "#{domain}.key") do
    remote_path "/#{node['letsencryptaws']['sync_path']}/#{domain}/privkey.pem"
    bucket node['letsencryptaws']['sync_bucket']
    aws_access_key_id (lazy { node['aws_access_key_id'] || aws_creds('aws_access_key_id') })
    aws_secret_access_key (lazy { node['aws_secret_access_key'] || aws_creds('aws_secret_access_key') })
    aws_session_token (lazy { node['aws_session_token'] || aws_creds('aws_session_token') })
    owner node['letsencryptaws']['ssl_owner']
    group node['letsencryptaws']['ssl_group']
    mode '640'
    retries 0
    ignore_failure true
    sensitive true
  end

  # Fall back to default certificate if real certificate isn't available yet
  file ::File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.crt") do
    owner node['letsencryptaws']['ssl_owner']
    group node['letsencryptaws']['ssl_group']
    mode '644'
    content (lazy { File.read(::File.join(node['letsencryptaws']['ssl_cert_dir'], 'default.crt')) })
    action :create_if_missing
  end

  file ::File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.ca") do
    owner node['letsencryptaws']['ssl_owner']
    group node['letsencryptaws']['ssl_group']
    mode '644'
    content (lazy { File.read(::File.join(node['letsencryptaws']['ssl_cert_dir'], 'default.ca')) })
    action :create_if_missing
  end

  file ::File.join(node['letsencryptaws']['ssl_key_dir'], "#{domain}.key") do
    owner node['letsencryptaws']['ssl_owner']
    group node['letsencryptaws']['ssl_group']
    mode '640'
    content (lazy { File.read(::File.join(node['letsencryptaws']['ssl_key_dir'], 'default.key')) })
    action :create_if_missing
    sensitive true
  end

  # Generate the chained certificate based on what's already there
  file ::File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.crt-chain") do
    owner node['letsencryptaws']['ssl_owner']
    group node['letsencryptaws']['ssl_group']
    mode '644'
    content (lazy do
      "#{File.read(::File.join(node['letsencryptaws']['ssl_cert_dir'],
                               "#{domain}.crt"))}\n#{File.read(::File.join(node['letsencryptaws']['ssl_cert_dir'],
                                                                           "#{domain}.ca"))}"
    end)
  end

  # Generate a PKCS12 file backed on what's already there
  execute "generate pkcs12 store for #{domain}" do
    cwd node['letsencryptaws']['ssl_key_dir']
    only_if { node['os'] == 'linux' }
    command (lazy do
               "openssl pkcs12 -export -in #{File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.crt")}" \
                 "  -inkey #{domain}.key -out #{domain}.p12 -name #{domain} " \
                 "  -passout \"pass:#{aws_creds('p12_password')}\"" \
                 "  -CAfile #{File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.ca")}" \
                 "  -CApath #{node['letsencryptaws']['root_ca_dir']} -caname letsencrypt -chain"
             end)
    action :nothing
    sensitive true
    only_if "openssl verify -CAfile #{::File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.ca")} " \
            "#{::File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.crt")}"
    subscribes :run, "remote_file_s3[#{::File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.crt")}]", :delayed
  end

  notify_block = proc do
    notifies :run, "execute[generate pkcs12 store for #{domain}]", :immediately
    not_if do
      File.exist?(::File.join(node['letsencryptaws']['ssl_key_dir'], "#{domain}.p12")) || aws_creds('p12_password').nil?
    end
  end

  send(respond_to?(:notify_group) ? :notify_group : :log, "pkcs12 store needs generated for #{domain}", &notify_block)

  file ::File.join(node['letsencryptaws']['ssl_key_dir'], "#{domain}.p12") do
    owner node['letsencryptaws']['ssl_owner']
    group node['letsencryptaws']['ssl_group']
    mode '640'
    not_if { aws_creds('p12_password').nil? }
  end
end

include_recipe 'letsencryptaws::import_keystore' unless node['letsencryptaws']['import_keystore'].empty? || \
                                                        node['os'] != 'linux'
